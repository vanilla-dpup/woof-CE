#!/bin/sh
# see also /sbin scripts: usablefs, switch
#
# _FN = _FILENAME
# _MP = _MOUNTPOINT
#

#Aufs layers setup by this script...
#overlay layers:            RW (top)      RO1             RO2              PUPMODE
#First boot (or pfix=ram):  tmpfs                         pup_xxx.sfs      5
#Normal running puppy:      pup_save.3fs                  pup_xxx.sfs      12
#ditto, but flash drive:    tmpfs         pup_save.3fs    pup_xxx.sfs      13

######################## localization ########################
L_WINDOWS_HIBERNATED="ERROR: Windows NTFS hibernated partition, cannot mount"
L_DONE="done"
L_FAILED="failed"
L_DUMPING_BOOTINIT_LOG="Dumping last lines of /tmp/bootinit.log..."
L_DUMPING_KERNEL_LOG="Dumping last lines of kernel log..."
L_ERROR_IS_TOO_CRITICAL="Error is too critical, dropping out to console..."
L_PAUSING_60_SECONDS="Pausing for 60 seconds..."
L_LOADING_FILE="Loading '%s'..." #printf
L_LOADING_PUPSAVE='Loading savefolder %s [%s]...' #printf
L_LOADING_PUPSAVE_FILE='Loading savefile %s [%s] (%s)...' #printf
L_ADDING_SAVE_LAYER_FAILED="adding %s to overlay stack failed." #printf
L_WAITING_FOR_DEV='Waiting %s seconds for slow storage devices [%s/%s].' #printf
L_WAITING_FOR_PART='Waiting for partition [%s]' #printf
L_PRE_MESSAGE="Loading puppy main sfs file."
L_ERR_PDRV_INCOMPLETE="%s information is incomplete." #printf
L_ERR_ONEPART_NOT_MOUNTED="%s is not mounted." #printf
L_ERR_ONEPART_NOT_OK="%s %s is not Ok." #printf
L_ERR_ONEPART_MOUNT_SFS_FAILED="%s %s mount of sfs failed." #printf
L_ERR_AUFS_SFS_FAILED="overlay mount of %s failed." #printf
L_ERR_TYPE_PUPSAVE="Type a number to choose which personal file to use:"
L_DROPPED_TO_INITRD_SHELL="Dropped to initramfs shell. Type 'exec switch' to continue booting Puppy."
L_SWITCH_ROOT="Performing a 'switch_root' to the overlay filesystem..."
L_0_NONE="0  none"
L_NO_DISTRO_SPECS="No DISTRO_SPECS file found, assuming that personal storage is empty."
L_DEBUG_SAVE="To save debug info to a partition, type 'debugsave'"

##############################################################

/sbin/usablefs # mount: /proc /sys /dev / (proc sysfs devtmpfs rootfs)

for i in $(cat /proc/cmdline) ; do
  case $i in
    loglevel=*)  LOGLEVEL=${i##*=}  ;;
  esac
done

export TERMINFO="/etc/terminfo"
export LANG=C
export INIT_SCRIPT=1

PATH="/bin:/sbin"
export KERNELVER="$(uname -r)"
. /DISTRO_SPECS #v412 has DISTRO_VERSION, DISTRO_FILE_PREFIX
. /etc/rc.d/functions_x

if [ ! "$LOGLEVEL" ] ; then
  echo '3' > /proc/sys/kernel/printk # '3' is the standard loglevel.
  LOGLEVEL=3
fi

#List the builtin filesystem support
KFILESYSTEMS="$(cat /proc/filesystems | grep -v "nodev" | grep -v "fuseblk" | sed -e "s#\t##g" | tr '\n' '|' | sed -e 's#|$##g')"

#List linux filesystems
LINUXFSLIST="ext2|ext3|ext4|xfs|btrfs|f2fs"

#Filesystem to be fsck
FSCKLIST="ext2|ext3|ext4|vfat|msdos|exfat"

#=============================================================
#                        FUNCTIONS
#=============================================================

fsck_func() {
# "$1" - partition device - ex: /dev/sdb2
# "$2" - fstype - ex: ext2
 case $2 in
  ext2|ext3|ext4) fsck_app='e2fsck -y' ;;
  #vfat)  fsck_app='fsck.fat -y'  ;;
  #exfat) fsck_app='exfatfsck'    ;;
  *) return ;;
 esac
 if [ "$(echo "$FSCKDPARTS" | grep "${1}|")" = "" ];then
  ${fsck_app} ${1} > /dev/console 2>&1 || sleep 3 #so the user has time to read the error msg..
  FSCKDPARTS="${FSCKDPARTS}${1}|"
 fi
}

check_status() #args: [-critical] $RET_VAL "$ERROR_MSG"
{
  ERROR_CRITICAL=""
  [ "$1" = "-critical" ] && { ERROR_CRITICAL="yes" ; shift; }
  RET_VAL=$1
  shift
  ERROR_MSG="$@"
  if [ $RET_VAL -eq 0 ] ; then
    echo -en "\\033[74G" >/dev/console #move to column 72. 110426: 74
    echo -e "\\033[1;32m${L_DONE}\\033[0;39m" >/dev/console #32=green
  else
    echo -en "\\033[72G" >/dev/console #move to column 72.
    echo -e "\\033[1;31m${L_FAILED}\\033[0;39m" >/dev/console #31=red
    if [ "$FLAG_NO_TIMEOUT" ] ; then
      FLAG_NO_TIMEOUT=
      return
    fi
    echo -e "\\033[1;35m${L_DUMPING_BOOTINIT_LOG}\\033[0;39m" >/dev/console #35=purple
    echo -en "\\033[1;31m" >/dev/console #31=red
    cat /tmp/bootinit.log | tail -n 4 >/dev/console
    echo -en "\\033[0;39m" >/dev/console
    echo -e "\\033[1;35m${L_DUMPING_KERNEL_LOG}\\033[0;39m" >/dev/console #35=purple
    echo -en "\\033[1;31m" >/dev/console #31=red
    dmesg | tail -n 4 >/dev/console
    echo -en "\\033[0;39m" >/dev/console
    #exit to initial ramdisk shell...
    [ "$RDSH" != "" ] && exec /bin/sh >/dev/console 2>&1
    if [ "$ERROR_CRITICAL" = "yes" ] ; then
      echo -en "\\033[1;35m" >/dev/console #35=purple
      [ "$ERROR_MSG" != "" ] && echo "*** $ERROR_MSG" >/dev/console
      echo "*** ${L_ERROR_IS_TOO_CRITICAL}" >/dev/console
      echo -en "\\033[0;39m" >/dev/console
      echo -e "\\033[1;32m*** $L_DEBUG_SAVE\\033[0;39m" >/dev/console
      exec /bin/sh >/dev/console 2>&1
    else
      echo "${L_PAUSING_60_SECONDS}" >/dev/console
      sleep 60
    fi
  fi
}

wait_for_blkid() {
 # $1 value to look for
 BLKID_PART=''
 [ "$1" ] || return
 local PART DIDMSG NUM
 DIDMSG=''
 # use loop to wait for device, if not found immediately
 for NUM in $(seq 1 15); do
  PART="$(blkid | grep "$1" | grep -E "^/dev/$1| LABEL=.$1| UUID=.$1" | cut -f1 -d':' | cut -f3 -d'/')"
  [ "$PART" ] && break
  [ $NUM -eq 1 ] && { echo -n "$(printf "$L_WAITING_FOR_PART" "${1}")" > /dev/console; DIDMSG='yes'; }
  sleep 1
  echo -en "\\033[1;33m.\\033[0;39m" >/dev/console #yellow dot
 done
 [ "$PART" ] && BLKID_PART="$PART"
 if [ "$DIDMSG" ];then
  get_part_info
  if [ "$PART" ];then
   check_status 0
  else
   check_status 1
  fi
 fi
}

decode_id() {
 ONE_PART=''
 [ "${1}" ] || return
 if grep -q " ${1}$" /proc/partitions;then #known partition name
  ONE_PART="$1"
  return
 fi
 wait_for_blkid "$1"
 ONE_PART="$BLKID_PART"
}

log_part_id() {
# "$1" - partition id - ex: Work or sdc4
 echo "Partition ${1} not found."
}

ensure_mounted() {
# "$1" - partition - ex: sda3
# "$2" - mountpoint - ex: /mnt/pdrv
 ONE_MP="$(grep -m1 "^/dev/${1} " /proc/mounts | cut -f 2 -d ' ')"
 if [ "$ONE_MP" ];then
  ONE_FS="$(grep -m1 "^/dev/${1} " /proc/mounts | cut -f 3 -d ' ')"
  return
 fi
 ONE_FS="$(blkid /dev/${1} | grep -o ' TYPE=.*' | cut -f 2 -d '"')"
 ONE_MP="${2}"
 if [ "$PFSCKP" = "yes" ] ; then # pfix=fsckp
   fsck_func /dev/${1} $ONE_FS
 fi
 /sbin/mountpartition /dev/${1} $ONE_MP $ONE_FS #-t $ONE_FS /dev/$ONE_PART $ONE_MP
 if [ $? -ne 0 ] ; then
  sleep 3 # usb optical drive showing as /sys/block/sr0, but won't mount, needs more delay...
  /sbin/mountpartition /dev/${1} $ONE_MP $ONE_FS
  [ $? -ne 0 ] && { echo "${1} on $ONE_MP as $ONE_FS mount failed."; ONE_MP=""; return 1; }
 fi
 # fsckme.flg is created by rc.sysinit and deleted by rc.shutdown
 # this flag will be set for any prior improper shutdown. if have lots of installations
 # of puppy on the pc, the flag may not even be for this install of puppy, however, this is
 # the simplest implementation...
 if [ -f ${ONE_MP}/fsckme.flg ] ; then
  #sda1,ext3,/PUPPYBOOT/precise/precisesave.4fs
  FSCKME="`cat ${ONE_MP}/fsckme.flg`"
  echo -e "${ONE_MP}/fsckme.flg\n  $FSCKME"
  FSCK_PART="$(echo "$FSCKME" | cut -f 1 -d ",")"
  FSCK_EXT="$(echo "$FSCKME" | cut -f 2 -d ",")"
  FSCK_SAVEFILE="$(echo "$FSCKME" | cut -f 3 -d ",")"
  rm -f ${ONE_MP}/fsckme.flg
  [ "$FSCK_SAVEFILE" ] && PFSCK="yes"
  [ "$PFSCKP" = "yes" ] && return # boot param, partition already fsck'ed
  
  if [ "$(echo "$FSCKLIST" | grep "${FSCK_EXT}")" != "" ]; then
    umount ${ONE_MP}
    [ "$FSCKME" ] && fsck_func /dev/${FSCK_PART} ${FSCK_EXT}
    ensure_mounted "$1" "$2"
  fi
  
 fi
}

ensure_save_mounted() {
 SAVE_MP="/mnt/dev_save"
 ensure_mounted "$SAVEPART" "$SAVE_MP"
 if [ "$ONE_MP" ];then
  if [ "$ONE_MP" != "$SAVE_MP" ];then
   #ensure SAVEPART is mounted on /mnt/dev_save
   [ -d "$SAVE_MP" ] || mkdir -p $SAVE_MP
   echo "mount -o move $ONE_MP $SAVE_MP" #debug
   mount -o move $ONE_MP $SAVE_MP
  fi
  SAVE_FS="$ONE_FS"
 else
  SAVE_MP=""
 fi
}

find_drv_file() {
# "$1" - mount point - ex: /mnt/pdrv
# "$2" - filename - ex: /pup/mydrv-1.2.3.sfs
# "$3" - look under root too - ex. 1
 ONE_SFS=""
 [ "${1}" ] || return
 [ "${2}" ] || return
 ONE_MP="${1}"
 ONE_TRY_FN="${PSUBDIR}/${2}"
 [ "$3" -a ! -e "${ONE_MP}${ONE_TRY_FN}" ] && ONE_TRY_FN="/$2"
 if [ -L "${ONE_MP}${ONE_TRY_FN}" ];then
   C_MP="$(readlink -f "$ONE_MP")"
   ONE_TRY_FN="$(readlink -f "${C_MP}${ONE_TRY_FN}")"
   ONE_TRY_FN="${ONE_TRY_FN#${C_MP}}"
 fi
 [ -f "${ONE_MP}${ONE_TRY_FN}" ] && ONE_SFS="${ONE_MP}${ONE_TRY_FN}"
}

do_stack_onepupdrv() {
# "$1" - sfs path - ex: /mnt/pdrv/pup/mydrv-1.2.3.sfs
# "$2" - suffix for "pup_" branch directory - ex: a
# "$3" - prepend after rw layer indicator - ex: p
 ONE_LAYER=""
 ONE_SFS="${1}"
 ONE_SFX="${2}"
 ONE_PREP="${3}"
 if ! [ -s "$ONE_SFS" ] ; then
   return 3 #sfs not Ok - empty file
 fi
 # ======= load_sfs_file()
 ONE_BASENAME="${ONE_SFS##*/}"
 echo -n "$(printf "${L_LOADING_FILE}" "$ONE_BASENAME")" > /dev/console
 #-
 ONE_LOOP="$(losetup -f)"
 losetup -r $ONE_LOOP $ONE_SFS
 SFS_MP="/pup_${ONE_SFX}"
 [ -d "$SFS_MP" ] || mkdir $SFS_MP
 mount -r -t squashfs -o noatime $ONE_LOOP $SFS_MP > /dev/console 2>&1
 STATUS=$? ; check_status $STATUS
 [ $STATUS -eq 0 ] && ONE_LAYER="$SFS_MP=rr"
 # ======= end of load_sfs_file()
 if ! [ "$ONE_LAYER" ] ; then
   return 4 #sfs mount failed
 fi
 if [ "$ONE_PREP" ];then
  remount_overlay -e "s~lowerdir=([^,]+)~lowerdir=${SFS_MP}:\1~" -e "s~lowerdir=,~lowerdir=${SFS_MP},~"
  [ $? -eq 0 ] || return 5
  NEWUNIONRECORD="${ONE_BASENAME} ${NEWUNIONRECORD}"
 else
  remount_overlay -e "s~lowerdir=([^,]+)~lowerdir=\1:${SFS_MP}~" -e "s~lowerdir=,~lowerdir=${SFS_MP},~"
  [ $? -eq 0 ] || return 5
  NEWUNIONRECORD="${NEWUNIONRECORD}${ONE_BASENAME} "
 fi
 if [ -z "$EXTRASFSLIST" ]; then
  EXTRASFSLIST="${ONE_NAME}"
 else
  EXTRASFSLIST="${EXTRASFSLIST} ${ONE_NAME}"
 fi
 return 0
}

stack_onepupdrv() {
# "$1" - sfs list - ex: /mnt/pdrv/pup/mydrv-1.2.3.sfs /mnt/pdrv/pup/otherdrv-1.2.3.sfs
# "$2" - sfs name - ex: mydrv-1.2.3.sfs
# "$3" - suffix for "pup_" branch directory - ex: a
# "$4" - prepend after rw layer indicator - ex: p
 SFS_LIST="${1}"
 SFS_NAME="${2}"
 ONE_SFX="${3}"
 ONE_PREP="${4}"

 FOUND=0
 for ONE_SFS in $SFS_LIST; do
  ONE_NAME="${ONE_SFS##*/}"
  [ "$ONE_NAME" = "$SFS_NAME" ] || continue
  FOUND=1
  break
 done
 [ $FOUND -eq 0 ] && return

 LOADED=0
 for ONE_LOADED in $NEWUNIONRECORD; do
  [ "$ONE_LOADED" = "$SFS_NAME" ] || continue
  LOADED=1
  break
 done
 [ $LOADED -eq 1 ] && continue

 do_stack_onepupdrv "$ONE_SFS" "$ONE_SFX" "$ONE_PREP"
}

setup_psave(){ # setup savefile or savefolder
 SAVE_REL_FN="$(echo "$PUPSAVE" | cut -f 3 -d ',')"
 if [ -f "${SAVE_MP}${SAVE_REL_FN}" ];then #savefile
  PUPSAVE_SIZE="$(fx_format_bytes $(stat -c %s "${SAVE_MP}${SAVE_REL_FN}"))"
  echo -n "$(printf "${L_LOADING_PUPSAVE_FILE}" "$SAVE_REL_FN" "$SAVEPART" "$PUPSAVE_SIZE")" > /dev/console
 else
  echo -n "$(printf "${L_LOADING_PUPSAVE}" "$SAVE_REL_FN" "$SAVEPART")" > /dev/console
 fi
 rm -r -f "$SAVE_LAYER"
 SAVE_FN="${SAVE_MP}${SAVE_REL_FN}"
 if [ -f "$SAVE_FN" ];then #savefile. ex: stretchsave.4fs
  echo "--SAVEFILE-- $SAVE_FN" #debug
  /sbin/load_ext_file "$SAVE_FN" "$SAVE_MP" #reads $PFSCK
  if [ -f /tmp/savefile_loop ] ; then
    . /tmp/savefile_loop # $SAVEFILE_LOOP $SFFS
    mkdir /pup_loop
    echo "mount -t $SFFS -o noatime $SAVEFILE_LOOP /pup_loop" #debug
    mount -t $SFFS -o noatime $SAVEFILE_LOOP /pup_loop
    if [ $? -ne 0 ]; then
      PUPSAVE=""
    else
      mkdir -p "/pup_loop/upper" "/pup_loop/work"
      ln -sv "/pup_loop/upper" "$SAVE_LAYER"
      ln -sv "/pup_loop/work" "$WORKDIR"
    fi
  else # load_ext_file failed
    FLAG_NO_TIMEOUT=1
    PUPSAVE=""
  fi
 elif [ -d "$SAVE_FN" ];then #savefolder
  echo "--SAVEFOLDER-- $SAVE_FN" #debug
  mkdir -p "$SAVE_FN/upper" "$SAVE_FN/work"
  ln -sv "$SAVE_FN/upper" "$SAVE_LAYER"
  ln -sv "$SAVE_FN/work" "$WORKDIR"
 else
  PUPSAVE=""
 fi
 #[ "$PUPSAVE" ] && decrypt directory at SAVE_LAYER
 if [ "$PUPSAVE" ];then
  SAVE_NAME="$(basename $SAVE_REL_FN)"
  #- fix for empty pupsaves (missing /initrd/DISTRO_SPECS)
  if [ ! -f "$SAVE_LAYER/initrd/DISTRO_SPECS" ] ; then
    touch /tmp/rc_update_force_pm5 # see /etc/rc.d/rc.update
    PCLEAN=""
  fi
  #-
  if [ "$PCLEAN" != "yes" -a -f "$SAVE_LAYER/initrd/DISTRO_SPECS" ];then
    validate_pupsave_upgrade /DISTRO_SPECS $SAVE_LAYER/initrd/DISTRO_SPECS
    case $? in
      0) PCLEAN="yes" ;; # perform upgrade
      1) PUPSAVE=""   ;; # do not perform upgrade
    esac
  fi
  if [ "$PCLEAN" = "yes" ];then
   #do upgrade processing
   touch /tmp/version_update_flag
   CURDIR="$(pwd)"
   cd "$SAVE_LAYER"
   #delete critical system files
   #keep rc.local - user customisations and/or fixes.
   echo "Removing $(ls ./lib/modules/$KERNELVER/modules.*)"
   rm -f ./lib/modules/$KERNELVER/modules.*
   RC_STUFF="$(ls ./etc/rc.d/rc.* | grep -v "/rc.local$" | tr '\n' ' ')"
   rm -fv $RC_STUFF
   rm -fv ./etc/rc.d/funct*
   #iterate over all files in save
   for ONE_FILE in $(find . -type c -print); do
    [ "`stat -c '%t,%T' "$ONE_FILE" 2>/dev/null`" != '0,0' ] && continue
    [ "${ONE_FILE%/*}" = "./root/.config/autostart" ] && continue #keep autostart changes
    echo "Removing ${ONE_FILE}" 
    rm -f "$ONE_FILE" #remove whiteout file
   done
   cd "$CURDIR"
   sync
  fi
  check_status 0
 else
  check_status 1
 fi
 if [ ! "$PUPSAVE" ] ; then
   echo "No pupsave. Setting PUPMODE 5" #debug
   if ! [ -L $SAVE_LAYER ] ; then # $SAVE_LAYER is a true mp
     echo -e "Unmounting savefile\numount -d $SAVE_LAYER" #debug
     umount -d $SAVE_LAYER
   fi
   PUPMODE=5
   SAVE_MP=""
   SAVE_LAYER=""
 fi
}

set_fs_linux() {
# "$1" - file system type - ex: ext4
 ONE_FS_IS_LINUX=""
 [ "$(echo "$LINUXFSLIST" | grep "$1")" != "" ] && ONE_FS_IS_LINUX="yes"
}

find_save_file() {
# "$1" - mount point - ex:  /mnt/pdrv
# "$2" - partition name - ex: sdb2
# "$3" - file system type - ex: ext4
 SAVE_DIR="${PSUBDIR}/"
 SAVE_FILES="$(ls -d ${1}${SAVE_DIR}${DISTRO_FILE_PREFIX}save* 2>/dev/null)"
 for ONE_SAVE in $SAVE_FILES;do
  #validate savefiles here
  IS_OK=""
  case $ONE_SAVE in
   *.2fs|*.3fs|*.4fs) [ -s "$ONE_SAVE" ] && IS_OK="yes" ;;
   *) [ "$ONE_FS_IS_LINUX" = "yes" ] && [ -d "$ONE_SAVE" ] && IS_OK="yes" ;;
  esac
  [ "$IS_OK" = "yes" ] && PUP_SAVES="${PUP_SAVES}${2},${3},${SAVE_DIR}$(basename $ONE_SAVE)
"
 done
 PUP_SAVES="$(echo "$PUP_SAVES")" #remove trailing newline char
}

search_func() {
 echo "HAVE_PARTS='${HAVE_PARTS}'" #debug
 if [ "${1}" ];then
  echo "param='${1}'" #debug
  TRY_PARTS_FIRST="$(echo "$HAVE_PARTS" | grep -E "${1}")"
  TRY_PARTS_LAST="$(echo "$HAVE_PARTS" | grep -Ev "${1}")"
  TRY_PARTS="$TRY_PARTS_FIRST
$TRY_PARTS_LAST"
 else
  TRY_PARTS="$HAVE_PARTS"
 fi
 echo "TRY_PARTS='${TRY_PARTS}'" #debug
 [ "$TRY_PARTS" ] || return
 for ONETRY in $TRY_PARTS;do
  ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d '|')"
  ensure_mounted "$ONE_PART" "/mnt/pdrv"
  if [ "$ONE_MP" ];then
   if [ "$LOOK_SAVE" -a "$SAVEPART" = "" ];then
    set_fs_linux "$ONE_FS"
    find_save_file "$ONE_MP" "$ONE_PART" "$ONE_FS"
    if [ "$PUP_SAVES" ];then
     SAVEPART="$ONE_PART"
    fi
   fi
   if [ "$LOOK_PUP" ];then
    find_drv_file /mnt/pdrv "$DISTRO_PUPPYSFS" ""
    if [ "$ONE_SFS" ];then
     PDRV="$ONE_PART,$ONE_FS,$ONE_SFS"
     PDRV_SFS="$ONE_SFS"
     P_PART="$ONE_PART"
     break;
    fi
   fi
   umount $ONE_MP
  fi
 done 
}

get_part_info() {
 probepart -hr > /tmp/probepart.log
 probedisk > /tmp/probedisk.log
 HAVE_PARTS="$(cat /tmp/probepart.log | grep -E "$KFILESYSTEMS" | cut -f 1-2 -d '|' | sed -e 's%/dev/%%')"
}

wait_for_dev() {
 echo -n "$(printf "$L_WAITING_FOR_DEV" "$WAITDEV")" > /dev/console
 for NUM in $(seq 1 $WAITDEV);do
  sleep 1
  echo -en "\\033[1;33m.\\033[0;39m" >/dev/console #yellow dot
 done
 get_part_info
 echo ""  > /dev/console
}

check_resize_part() { #must be fast, no partitions can be mounted, can't work out pupmode at this stage
 DEVICE=/dev/mmcblk0 # sd card only for now
 fdisk -l $DEVICE | grep -qm1 "using GPT" && return # bale out if GPT
 grep "$DEVICE" /tmp/probedisk.log | grep -q 'card' || return
 FS=`grep "$DEVICE" /tmp/probepart.log | tail -n1 | cut -f 2 -d '|'`
 case $FS in
  ext*|f2fs)
  echo "$FS : checking if it needs resizing"
  ;;
  *)
  return
  ;;
 esac
 DEVICE_SIZE=`fdisk -l $DEVICE | grep -om1 '[KMG]*B,.*bytes' | cut -f 2 -d ' '`
 DEVICE_SIZE=$(($DEVICE_SIZE / 1024)) # kb
 ACT_SIZE=0
 grep 'mmcblk0p' /proc/partitions | while read EACH_PART ; do
  PART_SIZE=`echo $EACH_PART | rev | cut -f 2 -d ' ' |rev` # kb
  ACT_SIZE=$(($PART_SIZE + $ACT_SIZE ))
  echo -n $ACT_SIZE > /tmp/actualsizekb
 done
 USED_SIZE=`cat /tmp/actualsizekb`
 DIFF_SIZE=$(($DEVICE_SIZE - $USED_SIZE))
 if [ $DIFF_SIZE -lt 10000 ] ; then # ~10 MB, can do it later
  return
 else
  /sbin/resize_part $FS
  check_status $?
 fi
}

fatal_error() {
# "$1" - message - ex: puppy_tahr_6.0.5.sfs not found
# "$2" - pre-status-message - ex: Finding puppy
 [ "${2}" ] && echo -n "${2}" > /dev/console
 check_status -critical 1 "$1"
}

remount_overlay() {
 OPTS=`grep '^unionfs /pup_new overlay' /proc/mounts | awk '{print $4}'`
 if [ -n "$OPTS" ]; then
  umount -l /pup_new
 else
  mkdir /mnt/tmpfs/pup_work
  OPTS="lowerdir=,upperdir=/mnt/tmpfs/pup_rw,workdir=/mnt/tmpfs/pup_work,xino=on,metacopy=off"
 fi
 NEWOPTS=`echo "$OPTS" | sed -E "$@"`
 echo "mount -t overlay -o ${NEWOPTS} unionfs /pup_new" #debug
 mount -t overlay -o ${NEWOPTS} unionfs /pup_new
 STATUS=$?
 if [ $STATUS -ne 0 ]; then
  echo "mount -t overlay -o ${OPTS} unionfs /pup_new" #debug
  mount -t overlay -o ${OPTS} unionfs /pup_new
 fi
 return $STATUS
}

#=============================================================
#                           MAIN
#=============================================================

clear #clear the screen.

echo -en "\\033[0;34m***\\033[0;37m ${DISTRO_NAME} ${DISTRO_VERSION}"
echo -en "\\033[0;34m -\\033[0;37m Linux ${KERNELVER} "
echo -en "\\033[0;31m[\\033[0;37m`uname -m`\\033[0;31m]"
echo -e "\\033[0;34m ***\\033[0;39m"

[ "$LOGLEVEL" -eq 7 ] && set -x
[ "$LOGLEVEL" -le 3 -o "$LOGLEVEL" -eq 7 ] && exec 1>/tmp/bootinit.log 2>&1 #remove o/p from console. v2.22 loglevel added.

#pmedia= usbflash|usbhd|usbcd|ataflash|atahd|atacd|atazip|scsihd|scsicd|cd
[ $pmedia ] && PMEDIA=$pmedia #boot parameter, broad category of boot media. ex: cd.
[ $psubdir ] && PSUBDIR=$psubdir #boot parameter, directory for puppy files. ex: puppy220

[ $PSUBDIR ] && [ "${PSUBDIR:0:1}" != "/" ] && PSUBDIR="/${PSUBDIR}" #add leading /.

[ $pupsfs ] && P_BP_ID=$pupsfs
#<partition>:<filename>, for savefile/savefolder. <partition> can be a name or Label or UUID
[ $psave ] && SAVE_BP_ID=$psave #ex: 49baa82d-8c69
if [ $waitdev ];then
 WAITDEV=$waitdev
else
 WAITDEV=5
fi

RDSH=""
if [ "$pfix" ];then
 for ONEFIX in $(echo -n "$pfix" | tr ',' ' ')
 do
  case $ONEFIX in
   ram)     PRAMONLY="yes";;      #run in ram only (do not load ${DISTRO_FILE_PREFIX}save).
   rdsh)    RDSH="yes";;          #exit to shell in initial ramdisk.
   nox)     PNOX="yes";;          #do not start X.
   clean)   PCLEAN="yes";;        #force version upgrade and cleanup.
   fsck)    PFSCK="yes";;         #do a fsck of ${DISTRO_FILE_PREFIX}save file.
   fsckp)   PFSCKP="yes";;        #do fsck before first mount of ext partitions
   *)       echo "pfix=$ONEFIX is not a known boot parameter";;
  esac
 done
fi

export PFSCK # read by /sbin/load_ext_file

[ "$TZ" ] && export TZ
hwclock -l -s

get_part_info

PUP_SAVES=""
FSCKDPARTS=""

#establish /mnt/pdrv
P_PART=""; SAVEPART=""; LOOK_PUP=""; LOOK_SAVE=""
if [ "$P_BP_ID" ];then #specified as parameter
 decode_id "$P_BP_ID"
 [ "$ONE_PART" ] && { P_PART="$ONE_PART"; P_BP_ID=""; }
 ensure_mounted "$P_PART" "/mnt/pdrv"
 if [ "$ONE_MP" ];then
  find_drv_file "/mnt/pdrv" "$DISTRO_PUPPYSFS" ""
  [ "$ONE_SFS" ] && { PDRV="$ONE_PART,$ONE_FS,$ONE_SFS"; PDRV_SFS="$ONE_SFS"; }
 fi
else #not specified anywhere
 #determine what to search for
 [ "$PMEDIA" = "cd" ] && LOOK_SAVE="yes"
 [ "$SAVE_BP_ID" ] && LOOK_SAVE=""
 LOOK_PUP=yes
fi

if [ "$LOOK_PUP" -o "$LOOK_SAVE" ];then #something to search for
 search_func
 NUM=0
 while [ "$LOOK_PUP" -a "$P_PART" = "" ] || [ "$LOOK_SAVE" -a "$SAVEPART" = "" ];do
  [ $NUM -ge $WAITDEV ] && break
  printf "${L_WAITING_FOR_DEV}\n" "$WAITDEV" "$NUM" "$WAITDEV" > /dev/console
  sleep 1
  get_part_info
  if [ "${PMEDIA:0:3}" = "usb" ] ; then
   USBDRVS="$(find /sys/block -maxdepth 1 -name 'sd*' -o -name 'sr*' | xargs -n 1 readlink 2>/dev/null | grep '/usb[0-9]' | rev | cut -f 1 -d '/' | rev | tr '\n' '|')"
   if [ "$USBDRVS" ] ; then
    search_func "${USBDRVS%|}"
   else
    search_func
   fi
  else
   search_func
  fi
  NUM=$(($NUM + 1))
 done
fi
[ "$P_BP_ID" ] && { log_part_id "$P_BP_ID"; ONE_PART="$P_BP_ID"; }
if [ "$PDRV_SFS" = "" ];then
 fatal_error "$DISTRO_PUPPYSFS not found." "Finding puppy main sfs file."
fi

check_resize_part

#establish SAVEPART
decode_id "$SAVE_BP_ID"
[ "$ONE_PART" ] && { SAVEPART="$ONE_PART"; SAVE_BP_ID=""; }

mount -t tmpfs tmpfs /mnt/tmpfs
[ -d "/mnt/tmpfs/pup_rw" ] || mkdir /mnt/tmpfs/pup_rw

NEWUNIONRECORD=""
EXTRASFSLIST=""

do_stack_onepupdrv "$PDRV_SFS" "ro2"
STATUS=$?
if [ $STATUS -gt 0 ];then
 P_PRE_MSG="${L_PRE_MESSAGE}"
 case $STATUS in
  1) fatal_error "$(printf "${L_ERR_PDRV_INCOMPLETE}" "$PDRV_SFS")" "$P_PRE_MSG" ;;
  3) fatal_error "$(printf "${L_ERR_ONEPART_NOT_OK}" "$ONE_PART" "$ONE_REL_FN")" "$P_PRE_MSG" ;;
  4) fatal_error "$(printf "${L_ERR_ONEPART_MOUNT_SFS_FAILED}" "$ONE_PART" "$ONE_REL_FN")" "$P_PRE_MSG" ;;
  5) fatal_error "$(printf "${L_ERR_AUFS_SFS_FAILED}" "$ONE_LAYER")" "$P_PRE_MSG" ;;
 esac
fi
PUP_LAYER="$SFS_MP"

#all partition id's should be decoded by now
[ "$SAVE_BP_ID" ] && log_part_id "$SAVE_BP_ID"

[ "$SAVEPART" ] || SAVEPART="$P_PART"

#ensure that save partition is mounted
#if SAVEPART is not the same as P_PART
#moved up here to ensure config files are available
[ "$SAVEPART" ] && ensure_save_mounted

#find PUPSAVE, sortout pupmode
PUPMODE=5

PUPSAVE=""
if [ "${SAVE_MP}" != "" -a "$PRAMONLY" != "yes" ];then #have mounted save? partition
 #check if save partition is linux
 set_fs_linux "$SAVE_FS"
 #check for save to partition 
 if [ "$ONE_FS_IS_LINUX" = "yes" -a "$PSUBDIR" = "" -a -f "${SAVE_MP}/etc/rc.d/PUPSTATE" ];then
  # make sure it's not a full install
  if ! grep -q 'PUPMODE=2' ${SAVE_MP}/etc/rc.d/PUPSTATE ; then
    # PUPMODE=6 PUPMODE=7 - unsupported
    if [ "$ONE_FS_IS_LINUX" = "yes" ] ; then #savefolder is a full partition
      PUPSAVE="$SAVEPART,$SAVE_FS,"
      PUPMODE=12
      ONE_PART="$(echo -n "$PUPSAVE" | cut -f 1 -d ',')"
      [ "$ONE_PART" != "$SAVEPART" ] && { SAVEPART="$ONE_PART"; ensure_save_mounted; }
    fi
  fi
 fi
 #not sorted yet, may be pupmode=12
 if [ $PUPMODE -eq 5 ];then
  #have to find savefile/savefolder
  [ "$PUP_SAVES" ] || find_save_file "${SAVE_MP}" "$SAVEPART" "$SAVE_FS"
  echo "PUP_SAVES=${PUP_SAVES}" #debug
  if [ "$PUP_SAVES" ];then
   NUMPUP_SAVES=0
   for ONE_SAVE in $PUP_SAVES;do
    NUMPUP_SAVES=$(expr $NUMPUP_SAVES + 1)
   done
   echo "NUMPUP_SAVES=${NUMPUP_SAVES}" #debug
   if [ $NUMPUP_SAVES -eq 1 ];then
    PUPSAVE="$(echo -n $PUP_SAVES)"
   elif [ $NUMPUP_SAVES -gt 1 ];then
    CNTSAVE=1
    echo -e "\\033[1;36m" >/dev/console #36=aquablue
    echo "${L_ERR_TYPE_PUPSAVE}" > /dev/console
    echo "${L_0_NONE}" > /dev/console
    for ONETRY in $PUP_SAVES
    do
     ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d ',')"
     ONE_FILE="$(echo -n "$ONETRY" | cut -f 3 -d ',')"
     echo -e "${CNTSAVE}  ${ONE_PART}\\033[10G${ONE_FILE}" > /dev/console #10 means move to that column.
     CNTSAVE=$(expr $CNTSAVE + 1)
    done
    echo -en "\\033[0;39m" >/dev/console
    read NUMSAVE
    #--  $NUMSAVE -ne 0 = have selected a PUPSAVE ...
    if [ $NUMSAVE -ne 0 ] ; then
     echo -e "\n----" #debug
     echo "Have selected pupsave $NUMSAVE" #debug
     PUPSAVE="$(echo -n $PUP_SAVES | cut -f $NUMSAVE -d ' ')"
     PSPATH="${SAVE_MP}/$(echo "$PUPSAVE" | cut -f 3 -d ',')"
     echo "PSPATH=${PSPATH}" #debug
    fi
    #----------------------------------------------------
   fi
  fi
  echo "PUPSAVE=${PUPSAVE}" #debug
  if [ "$PUPSAVE" ];then
   echo "Setting PUPMODE 12" #debug
   PUPMODE=12
   ONE_PART="$(echo -n "$PUPSAVE" | cut -f 1 -d ',')"
   [ "$ONE_PART" != "$SAVEPART" ] && { SAVEPART="$ONE_PART"; ensure_save_mounted; }
  fi
 fi
fi

SAVE_LAYER=""
WORKDIR="/pup_work"
if [ "$PUPSAVE" ];then #refine pupmode
 # refine pupmode
 if [ $PUPMODE -eq 12 ];then
  SAVE_LAYER="/pup_rw"
  if [ -z "$PMEDIA" -o "$PMEDIA" = "cd" ] ; then
   [ "`cat /sys/block/$(fx_get_drvname $SAVEPART)/removable`" = "1" ] && xPM=13
  fi
  if [ "${PMEDIA:3}" = "flash" -o "$xPM" = "13" ];then
   PUPMODE=$(($PUPMODE + 1)) #PUPMODE=13
   echo "Setting PUPMODE $PUPMODE" #debug
   SAVE_LAYER="/pup_ro1"
  fi
  echo "SAVE_LAYER=$SAVE_LAYER" #debug
 fi
fi

#load savefile if required, then setup stack
case $PUPMODE in
 13)
  setup_psave
  if [ "$PUPSAVE" ] ; then
    #prepend ro1 - #SAVE_LAYER=/pup_ro1
    rm -rf ${SAVE_LAYER}/tmp #in case last boot was pupmode=12
    mount -o remount,size=75% /mnt/tmpfs
    remount_overlay "s~lowerdir=([^,]+)~lowerdir=${SAVE_LAYER}:\1~"
    if [ $? -eq 0 ];then
      [ "$SAVE_NAME" ] && NEWUNIONRECORD="$SAVE_NAME $NEWUNIONRECORD"
    else
      printf "${L_ADDING_SAVE_LAYER_FAILED}\n" "$SAVE_LAYER"
    fi
  fi
 ;;
 12) #replace rw
  setup_psave
  if [ "$PUPSAVE" ] ; then
    #SAVE_LAYER=/pup_rw
    #setup empty /tmp on tmpfs for in stack
    rm -rf ${SAVE_LAYER}/tmp
    #adjust stack
    remount_overlay -e "s~upperdir=[^,]+~upperdir=${SAVE_LAYER}~" -e "s~workdir=[^,]+~workdir=${WORKDIR}~"
    if [ $? -eq 0 ];then
      rm -rf /mnt/tmpfs/pup_rw
      [ "$SAVE_NAME" ] && NEWUNIONRECORD="$SAVE_NAME $NEWUNIONRECORD"
    else
      printf "${L_ADDING_SAVE_LAYER_FAILED}\n" "$SAVE_LAYER"
    fi
  fi
 ;;
 5)
  SAVE_MP=""
 ;;
esac

EXTRASFSPATHS=`find /mnt/dev_save${PSUBDIR} /mnt/dev_save -maxdepth 1 -name '*.sfs' -size +0 -exec sh -c 'SFS={}; echo ${SFS##*/},$SFS' \; | sort -n | uniq | cut -f 2- -d ,`

# load traditional SFSs in the traditional order
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_BDRVSFS" "b" "p"
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_YDRVSFS" "y" "p"
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_ADRVSFS" "a" "p"
stack_onepupdrv "$EXTRASFSPATHS" "nlsx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs" "nls" ""
stack_onepupdrv "$EXTRASFSPATHS" "docx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs" "doc" ""
stack_onepupdrv "$EXTRASFSPATHS" "kbuild-${KERNELVER}.sfs" "k" ""
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_FDRVSFS" "f" ""
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_ZDRVSFS" "z" ""

# under PUPMODE 12, a dynamically loaded SFS may leave behind symlinks in the save layer
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin chroot /pup_new /usr/sbin/sfs_load.overlay --cli stop

# load all other SFSs, sorted numerically
CNT=3
for ONE_SFS in $EXTRASFSPATHS; do
 ONE_NAME="${ONE_SFS##*/}"

 # skip SFSs from other Puppy family distros
 case "$ONE_NAME" in
 *_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs) ;;
 puppy_*.sfs|*drv_*.sfs|kbuild-*.sfs) continue ;;
 esac

 stack_onepupdrv "$EXTRASFSPATHS" "$ONE_NAME" "ro${CNT}" ""
 CNT=$(($CNT + 1))
done

mkdir -p /pup_new/etc/rc.d
( # > /pup_new/etc/rc.d/PUPSTATE
echo "PUPMODE=$PUPMODE"
echo "PDEV1='$P_PART'"
echo "PUPSFS='$PDRV'"
echo "PUPSAVE='$PUPSAVE'"
echo "PMEDIA='$PMEDIA'"
echo '#these directories are overlay layers in /initrd...'
echo "RW_LAYER='/pup_rw'"
echo "SAVE_LAYER='$SAVE_LAYER'"
echo "PUP_LAYER='$PUP_LAYER'"
echo "#The partition that has the ${DISTRO_FILE_PREFIX}save file is mounted here..."
echo "PUP_HOME='${SAVE_MP}'"
echo '#(in /initrd) ...note, /mnt/home is a link to it.'
echo '#Partition no. override on boot drive to which session is (or will be) saved...'
echo "PSAVEPART='$SAVEPART'"
echo "PSUBDIR='$PSUBDIR'"
echo "PUNIONFS='overlay'"
) > /pup_new/etc/rc.d/PUPSTATE

if [ "$PUPSAVE" ];then
 xBOOTCONFIG="$(grep -v -e '^PREVUNIONRECORD' -e '^EXTRASFSLIST' /pup_new/etc/rc.d/BOOTCONFIG | sed -e 's/^LASTUNIONRECORD/PREVUNIONRECORD/')"
 echo "$xBOOTCONFIG" > /pup_new/etc/rc.d/BOOTCONFIG
else
 echo "PREVUNIONRECORD=''" >> /pup_new/etc/rc.d/BOOTCONFIG
fi
echo "EXTRASFSLIST='${EXTRASFSLIST}'" >> /pup_new/etc/rc.d/BOOTCONFIG
echo "LASTUNIONRECORD='$(echo -n $NEWUNIONRECORD)'" >> /pup_new/etc/rc.d/BOOTCONFIG

echo -n "${L_SWITCH_ROOT}" > /dev/console

echo "Moving mountpoints to /pup_new/initrd for after switch..." #debug
rm -r -f "/pup_new/initrd${SAVE_LAYER}"
for ONEMNT in $(mount | cut -f 3 -d ' ' | grep -v 'pup_new' | grep '^/pup_' | tr '\n' ' ');do
 mkdir -p /pup_new/initrd${ONEMNT}
 echo "mount -o move $ONEMNT /pup_new/initrd${ONEMNT}" #debug
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done
for ONEMNT in $(mount | cut -f 3 -d ' ' | grep '^/mnt/' | tr '\n' ' ');do
 mkdir -p /pup_new/initrd${ONEMNT}
 echo "mount -o move $ONEMNT /pup_new/initrd${ONEMNT}" #debug
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done

echo "SAVE_FN=$SAVE_FN"         #debug
echo "SAVE_LAYER=${SAVE_LAYER}" #debug

# --- create/fix symlinks to /pup_new/initrd/* for after switch

# remove symbolic links for after switch, that might be leftover
[ -L /pup_new/initrd/pup_rw ] && rm -rf /pup_new/initrd/pup_rw
[ -L /pup_new/initrd/pup_ro1 ] && rm -rf /pup_new/initrd/pup_ro1
[ -L /pup_new/tmp ] && rm -fv /pup_new/tmp

# SAVE_LAYER: /pup_rw or /pup_ro1
# savefolder: create symlink to the save layer mountpoint in /pup_new/initrd
# (for savefiles and savepartitions the SAVE_LAYER is not a symlink)
if [ "$PUPSAVE" ];then
 if [ "$SAVE_LAYER" -a -L "$SAVE_LAYER" ];then
  ln -sv "/initrd`readlink ${SAVE_LAYER}`" "/pup_new/initrd${SAVE_LAYER}" #for after switch
 fi
fi

# symlinks to /pup_new/initrd/tmpfs subdirs
# * /pup_rw:  pupmodes 5,13
# * /pup_ro1: in PUPMODE 13 pup_ro1 is part of the tmpfs but an overlay read-only branch
#             where the previous session is stored to build the final filesystem
# * (rm -rf ... is an extra measure to ensure deletion
#     since an actual directory might be there and therefore was not deleted.)
if ! grep -q '/pup_new/initrd/pup_rw' /proc/mounts ; then
  if [ -d /pup_new/initrd/mnt/tmpfs/pup_rw ] ; then
    rm -rf /pup_new/initrd/pup_rw
    ln -sv /initrd/mnt/tmpfs/pup_rw /pup_new/initrd/pup_rw #for after switch
  fi
fi
if [ -d /pup_new/initrd/mnt/tmpfs/pup_ro1 ] ; then
  rm -rf /pup_new/initrd/pup_ro1
  ln -sv /initrd/mnt/tmpfs/pup_ro1 /pup_new/initrd/pup_ro1 #for after switch
fi
mkdir -p /pup_new/initrd/mnt/tmpfs/tmp
if [ -d /pup_new/initrd/mnt/tmpfs/tmp ];then #extra paranoid precaution
 chmod 1777 /pup_new/initrd/mnt/tmpfs/tmp
 rm -rf /pup_new/tmp
 ln -sv /initrd/mnt/tmpfs/tmp /pup_new/tmp #for after switch
fi

#---

#PNOX is a boot param. /etc/profile prevents X from starting if this file exists...
[ "$PNOX" = "yes" ] && touch /pup_new/initrd/mnt/tmpfs/tmp/bootcnt.txt

cp -a /DISTRO_SPECS /pup_new/initrd/
[ ! -f /pup_new/etc/DISTRO_SPECS ] && cp -a /DISTRO_SPECS /pup_new/etc/
dmesg > /tmp/dmesg.txt

[ -d "/pup_new/initrd/tmp" ] && rm -rf /pup_new/initrd/tmp
mkdir -p /pup_new/initrd/tmp
cp -af /tmp/* /pup_new/initrd/tmp/ #keep any log files.

if [ "$RDSH" = "yes" ];then
 echo > /dev/console
 echo "${L_DROPPED_TO_INITRD_SHELL}" > /dev/console
 exec /bin/sh >/dev/console 2>&1
fi

sync
[ -d "/proc/bus/usb" ] && umount /proc/bus/usb
umount /sys
umount /dev
umount /proc

#now using cpio archive for initramfs 'initial ramdisk'...
exec switch_root /pup_new /usr/local/sbin/init

###END###
