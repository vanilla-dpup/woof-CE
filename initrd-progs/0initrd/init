#!/bin/sh
# see also /sbin scripts: usablefs, switch
#
# _FN = _FILENAME
# _MP = _MOUNTPOINT
#

#Aufs layers setup by this script...
#overlay layers:            RW (top)      RO1             RO2              PUPMODE
#First boot (or pfix=ram):  tmpfs                         pup_xxx.sfs      5
#Normal running puppy:      pup_save.3fs                  pup_xxx.sfs      12
#ditto, but flash drive:    tmpfs         pup_save.3fs    pup_xxx.sfs      13

######################## localization ########################
L_DONE="done"
L_FAILED="failed"
L_DUMPING_BOOTINIT_LOG="Dumping last lines of /tmp/bootinit.log..."
L_DUMPING_KERNEL_LOG="Dumping last lines of kernel log..."
L_ERROR_IS_TOO_CRITICAL="Error is too critical, dropping out to console..."
L_PAUSING_60_SECONDS="Pausing for 60 seconds..."
L_LOADING_FILE="Loading '%s'..." #printf
L_LOADING_PUPSAVE='Loading savefolder %s [%s]...' #printf
L_LOADING_PUPSAVE_FILE='Loading savefile %s [%s]...' #printf
L_ADDING_SAVE_LAYER_FAILED="adding %s to overlay stack failed." #printf
L_WAITING_FOR_DEV='Waiting %s seconds for slow storage devices [%s/%s].' #printf
L_WAITING_FOR_PART='Waiting for partition [%s]' #printf
L_BOOT_FASTER='set %s to boot faster!' #printf
L_PRE_MESSAGE="Loading puppy main sfs file."
L_ERR_PDRV_INCOMPLETE="%s information is incomplete." #printf
L_ERR_ONEPART_NOT_OK="%s %s is not Ok." #printf
L_ERR_ONEPART_MOUNT_SFS_FAILED="%s %s mount of sfs failed." #printf
L_ERR_AUFS_SFS_FAILED="overlay mount of %s failed." #printf
L_ERR_TYPE_PUPSAVE="Type a number to choose which personal file to use:"
L_DROPPED_TO_INITRD_SHELL="Dropped to initramfs shell. Type 'exec switch' to continue booting Puppy."
L_SWITCH_ROOT="Performing a 'switch_root' to the overlay filesystem..."
L_0_NONE="0  none"
L_DEBUG_SAVE="To save debug info to a partition, type 'debugsave'"

##############################################################

/sbin/usablefs # mount: /proc /sys /dev / (proc sysfs devtmpfs rootfs)

for i in $(cat /proc/cmdline) ; do
  case $i in
    loglevel=*)  LOGLEVEL=${i##*=}  ;;
  esac
done

export INIT_SCRIPT=1

PATH="/bin:/sbin"
export KERNELVER="$(uname -r)"
. /DISTRO_SPECS #v412 has DISTRO_VERSION, DISTRO_FILE_PREFIX

if [ ! "$LOGLEVEL" ] ; then
  echo '3' > /proc/sys/kernel/printk # '3' is the standard loglevel.
  LOGLEVEL=3
fi

#=============================================================
#                        FUNCTIONS
#=============================================================

fsck_func() {
# "$1" - partition device - ex: /dev/sdb2
# "$2" - fstype - ex: ext2
 case $2 in
  ext2|ext3|ext4) fsck_app='e2fsck -y' ;;
  f2fs) fsck_app='fsck.f2fs -y' ;;
  msdos|vfat) fsck_app='fsck.fat -y' ;;
  exfat) fsck_app='fsck.exfat -y' ;;
  *) return ;;
 esac
 if [ "$(echo "$FSCKDPARTS" | grep "${1}|")" = "" ];then
  ${fsck_app} ${1} > /dev/console 2>&1 || sleep 3 #so the user has time to read the error msg..
  FSCKDPARTS="${FSCKDPARTS}${1}|"
 fi
}

check_status() #args: [-critical] $RET_VAL "$ERROR_MSG"
{
  ERROR_CRITICAL=""
  [ "$1" = "-critical" ] && { ERROR_CRITICAL="yes" ; shift; }
  RET_VAL=$1
  shift
  ERROR_MSG="$@"
  if [ $RET_VAL -eq 0 ] ; then
    echo -en "\\033[74G" >/dev/console #move to column 72. 110426: 74
    echo -e "\\033[1;32m${L_DONE}\\033[0;39m" >/dev/console #32=green
  else
    echo -en "\\033[72G" >/dev/console #move to column 72.
    echo -e "\\033[1;31m${L_FAILED}\\033[0;39m" >/dev/console #31=red
    if [ "$FLAG_NO_TIMEOUT" ] ; then
      FLAG_NO_TIMEOUT=
      return
    fi
    echo -e "\\033[1;35m${L_DUMPING_BOOTINIT_LOG}\\033[0;39m" >/dev/console #35=purple
    echo -en "\\033[1;31m" >/dev/console #31=red
    cat /tmp/bootinit.log | tail -n 4 >/dev/console
    echo -en "\\033[0;39m" >/dev/console
    echo -e "\\033[1;35m${L_DUMPING_KERNEL_LOG}\\033[0;39m" >/dev/console #35=purple
    echo -en "\\033[1;31m" >/dev/console #31=red
    dmesg | tail -n 4 >/dev/console
    echo -en "\\033[0;39m" >/dev/console
    #exit to initial ramdisk shell...
    [ "$RDSH" != "" ] && exec /bin/sh >/dev/console 2>&1
    if [ "$ERROR_CRITICAL" = "yes" ] ; then
      echo -en "\\033[1;35m" >/dev/console #35=purple
      [ "$ERROR_MSG" != "" ] && echo "*** $ERROR_MSG" >/dev/console
      echo "*** ${L_ERROR_IS_TOO_CRITICAL}" >/dev/console
      echo -en "\\033[0;39m" >/dev/console
      echo -e "\\033[1;32m*** $L_DEBUG_SAVE\\033[0;39m" >/dev/console
      exec /bin/sh >/dev/console 2>&1
    else
      echo "${L_PAUSING_60_SECONDS}" >/dev/console
      sleep 60
    fi
  fi
}

wait_for_blkid() {
 # $1 value to look for
 BLKID_PART=''
 [ "$1" ] || return
 # use loop to wait for device, if not found immediately
 for NUM in $(seq 1 15); do
  BLKID_PART="$(blkid | grep "$1" | grep -E "^/dev/$1| LABEL=.$1| UUID=.$1" | cut -f1 -d':' | cut -f3 -d'/')"
  if [ "$BLKID_PART" ]; then
   [ $NUM -gt 1 ] && check_status 0
   return
  fi
  [ $NUM -eq 1 ] && echo -n "$(printf "$L_WAITING_FOR_PART" "${1}")" > /dev/console
  sleep 1
  echo -en "\\033[1;33m.\\033[0;39m" >/dev/console #yellow dot
 done
 check_status 1
}

decode_id() {
 ONE_PART=''
 [ "${1}" ] || return
 if grep -q " ${1}$" /proc/partitions;then #known partition name
  ONE_PART="$1"
  return
 fi
 wait_for_blkid "$1"
 ONE_PART="$BLKID_PART"
}

log_part_id() {
# "$1" - partition id - ex: Work or sdc4
 echo "Partition ${1} not found."
}

ensure_mounted() {
# "$1" - partition - ex: sda3
# "$2" - mountpoint - ex: /mnt/pdrv
 ONE_MP="$(grep -m1 "^/dev/${1} " /proc/mounts | cut -f 2 -d ' ')"
 if [ "$ONE_MP" ];then
  ONE_FS="$(grep -m1 "^/dev/${1} " /proc/mounts | cut -f 3 -d ' ')"
  return
 fi
 ONE_FS="$(blkid /dev/${1} | grep -o ' TYPE=.*' | cut -f 2 -d '"')"
 ONE_MP="${2}"
 if [ "$PFSCKP" = "yes" ] ; then # pfix=fsckp
   fsck_func /dev/${1} $ONE_FS
 fi
 /sbin/mountpartition /dev/${1} $ONE_MP $ONE_FS #-t $ONE_FS /dev/$ONE_PART $ONE_MP
 [ $? -ne 0 ] && { echo "${1} on $ONE_MP as $ONE_FS mount failed."; ONE_MP=""; return 1; }
}

ensure_save_mounted() {
 SAVE_MP="/mnt/dev_save"
 ensure_mounted "$SAVEPART" "$SAVE_MP"
 if [ "$ONE_MP" ];then
  if [ "$ONE_MP" != "$SAVE_MP" ];then
   #ensure SAVEPART is mounted on /mnt/dev_save
   echo "mount -o move $ONE_MP $SAVE_MP" #debug
   mount -o move $ONE_MP $SAVE_MP
  fi
  SAVE_FS="$ONE_FS"
 else
  SAVE_MP=""
 fi
}

find_drv_file() {
# "$1" - mount point - ex: /mnt/pdrv
# "$2" - filename - ex: /pup/mydrv-1.2.3.sfs
# "$3" - look under root too - ex. 1
 ONE_SFS=""
 [ "${1}" ] || return
 [ "${2}" ] || return
 ONE_MP="${1}"
 ONE_TRY_FN="${PSUBDIR}/${2}"
 [ "$3" -a ! -e "${ONE_MP}${ONE_TRY_FN}" ] && ONE_TRY_FN="/$2"
 if [ -L "${ONE_MP}${ONE_TRY_FN}" ];then
   C_MP="$(readlink -f "$ONE_MP")"
   ONE_TRY_FN="$(readlink -f "${C_MP}${ONE_TRY_FN}")"
   ONE_TRY_FN="${ONE_TRY_FN#${C_MP}}"
 fi
 [ -f "${ONE_MP}${ONE_TRY_FN}" ] && ONE_SFS="${ONE_MP}${ONE_TRY_FN}"
}

do_stack_onepupdrv() {
# "$1" - sfs path - ex: /mnt/pdrv/pup/mydrv-1.2.3.sfs
# "$2" - suffix for "pup_" branch directory - ex: a
# "$3" - prepend after rw layer indicator - ex: p
 ONE_LAYER=""
 ONE_SFS="${1}"
 ONE_SFX="${2}"
 ONE_PREP="${3}"
 if ! [ -s "$ONE_SFS" ] ; then
   return 3 #sfs not Ok - empty file
 fi
 # ======= load_sfs_file()
 ONE_BASENAME="${ONE_SFS##*/}"
 echo -n "$(printf "${L_LOADING_FILE}" "$ONE_BASENAME")" > /dev/console
 #-
 ONE_LOOP="$(losetup -f)"
 losetup -r $ONE_LOOP $ONE_SFS
 SFS_MP="/pup_${ONE_SFX}"
 mkdir -p $SFS_MP
 mount -r -t squashfs -o noatime $ONE_LOOP $SFS_MP > /dev/console 2>&1
 STATUS=$? ; check_status $STATUS
 [ $STATUS -eq 0 ] && ONE_LAYER="$SFS_MP=rr"
 # ======= end of load_sfs_file()
 if ! [ "$ONE_LAYER" ] ; then
   return 4 #sfs mount failed
 fi
 if [ "$ONE_PREP" ];then
  remount_overlay -e "s~lowerdir=([^,]+)~lowerdir=${SFS_MP}:\1~" -e "s~lowerdir=,~lowerdir=${SFS_MP},~"
  [ $? -eq 0 ] || return 5
  NEWUNIONRECORD="${ONE_BASENAME} ${NEWUNIONRECORD}"
 else
  remount_overlay -e "s~lowerdir=([^,]+)~lowerdir=\1:${SFS_MP}~" -e "s~lowerdir=,~lowerdir=${SFS_MP},~"
  [ $? -eq 0 ] || return 5
  NEWUNIONRECORD="${NEWUNIONRECORD}${ONE_BASENAME} "
 fi
 return 0
}

stack_onepupdrv() {
# "$1" - sfs list - ex: /mnt/pdrv/pup/mydrv-1.2.3.sfs /mnt/pdrv/pup/otherdrv-1.2.3.sfs
# "$2" - sfs name - ex: mydrv-1.2.3.sfs
# "$3" - suffix for "pup_" branch directory - ex: a
# "$4" - prepend after rw layer indicator - ex: p
 SFS_LIST="${1}"
 SFS_NAME="${2}"
 ONE_SFX="${3}"
 ONE_PREP="${4}"

 FOUND=0
 for ONE_SFS in $SFS_LIST; do
  ONE_NAME="${ONE_SFS##*/}"
  [ "$ONE_NAME" = "$SFS_NAME" ] || continue
  FOUND=1
  break
 done
 [ $FOUND -eq 0 ] && return 1

 LOADED=0
 for ONE_LOADED in $NEWUNIONRECORD; do
  [ "$ONE_LOADED" = "$SFS_NAME" ] || continue
  LOADED=1
  break
 done
 [ $LOADED -eq 1 ] && return 1

 do_stack_onepupdrv "$ONE_SFS" "$ONE_SFX" "$ONE_PREP"
}

setup_psave(){ # setup savefile or savefolder
 SAVE_REL_FN="$(echo "$PUPSAVE" | cut -f 3 -d ',')"
 if [ -f "${SAVE_MP}${SAVE_REL_FN}" ];then #savefile
  echo -n "$(printf "${L_LOADING_PUPSAVE_FILE}" "$SAVE_REL_FN" "$SAVEPART")" > /dev/console
 else
  echo -n "$(printf "${L_LOADING_PUPSAVE}" "$SAVE_REL_FN" "$SAVEPART")" > /dev/console
 fi
 rm -r -f "$SAVE_LAYER"
 SAVE_FN="${SAVE_MP}${SAVE_REL_FN}"
 if [ -f "$SAVE_FN" ];then #savefile. ex: stretchsave.4fs
  echo "--SAVEFILE-- $SAVE_FN" #debug
  /sbin/load_ext_file "$SAVE_FN" "$SAVE_MP" #reads $PFSCK
  if [ -f /tmp/savefile_loop ] ; then
    . /tmp/savefile_loop # $SAVEFILE_LOOP
    mkdir /pup_loop
    echo "mount -o noatime $SAVEFILE_LOOP /pup_loop" #debug
    mount -o noatime $SAVEFILE_LOOP /pup_loop
    if [ $? -ne 0 ]; then
      PUPSAVE=""
    else
      if [ -s /pup_loop/.pfscrypt ]; then
        echo -e "\n----" > /dev/console
        PFSCRYPT_DIRS=""
        while read PFSCRYPT_DIR; do
          PFSCRYPT_DIRS="${PFSCRYPT_DIRS} /pup_loop/${PFSCRYPT_DIR}"
        done < /pup_loop/.pfscrypt
        pfscrypt /pup_loop "" $PFSCRYPT_DIRS > /dev/console 2>&1 || PUPSAVE=""
        echo -n "----" > /dev/console
      fi
      if [ "$PUPSAVE" ];then
        mkdir -p "/pup_loop/upper" "/pup_loop/work"
        ln -sv "/pup_loop/upper" "$SAVE_LAYER"
        ln -sv "/pup_loop/work" "$WORKDIR"
      fi
    fi
  else # load_ext_file failed
    FLAG_NO_TIMEOUT=1
    PUPSAVE=""
  fi
 elif [ -d "$SAVE_FN" ];then #savefolder
  echo "--SAVEFOLDER-- $SAVE_FN" #debug
  if [ -s "$SAVE_FN/.pfscrypt" ]; then
   echo -e "\n----" > /dev/console
   PFSCRYPT_DIRS=""
   while read PFSCRYPT_DIR; do
    PFSCRYPT_DIRS="${PFSCRYPT_DIRS} ${SAVE_REL_FN#/}/${PFSCRYPT_DIR}"
   done < "$SAVE_FN/.pfscrypt"
   pfscrypt "$SAVE_MP" "" $PFSCRYPT_DIRS > /dev/console 2>&1 || PUPSAVE=""
   echo -n "----" > /dev/console
  fi
  if [ "$PUPSAVE" ];then
   mkdir -p "$SAVE_FN/upper" "$SAVE_FN/work"
   ln -sv "$SAVE_FN/upper" "$SAVE_LAYER"
   ln -sv "$SAVE_FN/work" "$WORKDIR"
  fi
 else
  PUPSAVE=""
 fi
 #[ "$PUPSAVE" ] && decrypt directory at SAVE_LAYER
 if [ "$PUPSAVE" ];then
  SAVE_NAME="$(basename $SAVE_REL_FN)"
  validate_pupsave_upgrade /DISTRO_SPECS $SAVE_LAYER/initrd/DISTRO_SPECS
  case $? in
    0) touch /tmp/version_update_flag ;; # perform upgrade
    1) PUPSAVE=""   ;; # do not perform upgrade
  esac
  check_status 0
 else
  check_status 1
 fi
 if [ ! "$PUPSAVE" ] ; then
   echo "No pupsave. Setting PUPMODE 5" #debug
   if ! [ -L $SAVE_LAYER ] ; then # $SAVE_LAYER is a true mp
     echo -e "Unmounting savefile\numount -d $SAVE_LAYER" #debug
     umount -d $SAVE_LAYER
   fi
   PUPMODE=5
   SAVE_MP=""
   SAVE_LAYER=""
 fi
}

find_save_file() {
# "$1" - mount point - ex:  /mnt/pdrv
# "$2" - partition name - ex: sdb2
# "$3" - file system type - ex: ext4
 SAVE_DIR="${PSUBDIR}/"
 SAVE_FILES="$(ls -d ${1}${SAVE_DIR}${DISTRO_FILE_PREFIX}save* 2>/dev/null)"
 for ONE_SAVE in $SAVE_FILES;do
  #validate savefiles here
  IS_OK=""
  case $ONE_SAVE in
   *.4fs) [ -s "$ONE_SAVE" ] && IS_OK="yes" ;;
   *) [ -d "$ONE_SAVE" ] && IS_OK="yes" ;;
  esac
  [ "$IS_OK" = "yes" ] && PUP_SAVES="${PUP_SAVES}${2},${3},${SAVE_DIR}$(basename $ONE_SAVE)
"
 done
 PUP_SAVES="$(echo "$PUP_SAVES")" #remove trailing newline char
}

search_func() {
 while read ONE_PART;do
  ensure_mounted "$ONE_PART" "/mnt/$ONE_PART"
  if [ "$ONE_MP" ];then
   if [ "$LOOK_SAVE" ];then
    find_save_file "$ONE_MP" "$ONE_PART" "$ONE_FS"
    if [ "$PUP_SAVES" ];then
     printf "\\033[1;35m${L_BOOT_FASTER}\n\\033[0;39m" psave=$(blkid /dev/${ONE_PART} | tr ' ' '\n' | grep ^UUID= | cut -f 2 -d \") >/dev/console
     SAVEPART="$ONE_PART"
     LOOK_SAVE=""
    fi
   fi
   if [ "$LOOK_PUP" ];then
    find_drv_file "$ONE_MP" "$DISTRO_PUPPYSFS" ""
    if [ "$ONE_SFS" ];then
     printf "\\033[1;35m${L_BOOT_FASTER}\n\\033[0;39m" pupsfs=$(blkid /dev/${ONE_PART} | tr ' ' '\n' | grep ^UUID= | cut -f 2 -d \") >/dev/console
     PDRV_SFS="$ONE_SFS"
     P_PART="$ONE_PART"
     DEV1FS="$ONE_FS"
     LOOK_PUP=""
    fi
   fi
   umount $ONE_MP
   [ "$LOOK_PUP" -o "$LOOK_SAVE" ] || break
  fi
 done < <(lsblk -rno type,name | grep ^part | cut -f 2 -d ' ')
}

fatal_error() {
# "$1" - message - ex: puppy_tahr_6.0.5.sfs not found
# "$2" - pre-status-message - ex: Finding puppy
 [ "${2}" ] && echo -n "${2}" > /dev/console
 check_status -critical 1 "$1"
}

remount_overlay() {
 OPTS=`grep '^unionfs /pup_new overlay' /proc/mounts | awk '{print $4}'`
 if [ -n "$OPTS" ]; then
  umount -l /pup_new
 else
  mkdir /mnt/tmpfs/pup_work
  OPTS="lowerdir=,upperdir=/mnt/tmpfs/pup_rw,workdir=/mnt/tmpfs/pup_work,xino=on,metacopy=off"
 fi
 NEWOPTS=`echo "$OPTS" | sed -E "$@"`
 echo "mount -t overlay -o ${NEWOPTS} unionfs /pup_new" #debug
 mount -t overlay -o ${NEWOPTS} unionfs /pup_new
 STATUS=$?
 if [ $STATUS -ne 0 ]; then
  echo "mount -t overlay -o ${OPTS} unionfs /pup_new" #debug
  mount -t overlay -o ${OPTS} unionfs /pup_new
 fi
 return $STATUS
}

#=============================================================
#                           MAIN
#=============================================================

clear #clear the screen.

echo -en "\\033[0;34m***\\033[0;37m ${DISTRO_NAME} ${DISTRO_VERSION}"
echo -en "\\033[0;34m -\\033[0;37m Linux ${KERNELVER} "
echo -en "\\033[0;31m[\\033[0;37m`uname -m`\\033[0;31m]"
echo -e "\\033[0;34m ***\\033[0;39m"

[ "$LOGLEVEL" -eq 7 ] && set -x
[ "$LOGLEVEL" -le 3 -o "$LOGLEVEL" -eq 7 ] && exec 1>/tmp/bootinit.log 2>&1 #remove o/p from console. v2.22 loglevel added.

#pmedia= usbflash|usbhd|usbcd|ataflash|atahd|atacd|atazip|scsihd|scsicd|cd
[ $pmedia ] && PMEDIA=$pmedia #boot parameter, broad category of boot media. ex: cd.
[ $psubdir ] && PSUBDIR=$psubdir #boot parameter, directory for puppy files. ex: puppy220

[ $PSUBDIR ] && [ "${PSUBDIR:0:1}" != "/" ] && PSUBDIR="/${PSUBDIR}" #add leading /.

[ $pupsfs ] && P_BP_ID=$pupsfs
#<partition>:<filename>, for savefile/savefolder. <partition> can be a name or Label or UUID
[ $psave ] && SAVE_BP_ID=$psave #ex: 49baa82d-8c69
if [ $waitdev ];then
 WAITDEV=$waitdev
else
 WAITDEV=5
fi

RDSH=""
if [ "$pfix" ];then
 for ONEFIX in $(echo -n "$pfix" | tr ',' ' ')
 do
  case $ONEFIX in
   ram)     PRAMONLY="yes";;      #run in ram only (do not load ${DISTRO_FILE_PREFIX}save).
   rdsh)    RDSH="yes";;          #exit to shell in initial ramdisk.
   nox)     PNOX="yes";;          #do not start X.
   fsck)    PFSCK="yes";;         #do a fsck of ${DISTRO_FILE_PREFIX}save file.
   fsckp)   PFSCKP="yes";;        #do fsck before first mount of ext partitions
   *)       echo "pfix=$ONEFIX is not a known boot parameter";;
  esac
 done
fi

export PFSCK # read by /sbin/load_ext_file

[ "$TZ" ] && export TZ
hwclock -l -s

PUP_SAVES=""
FSCKDPARTS=""

#establish /mnt/pdrv
P_PART=""; SAVEPART=""; LOOK_PUP=""; LOOK_SAVE=""
if [ "$P_BP_ID" ];then #specified as parameter
 decode_id "$P_BP_ID"
 [ "$ONE_PART" ] && { P_PART="$ONE_PART"; P_BP_ID=""; }
 ensure_mounted "$P_PART" "/mnt/pdrv"
 if [ "$ONE_MP" ];then
  find_drv_file "/mnt/pdrv" "$DISTRO_PUPPYSFS" ""
  [ "$ONE_SFS" ] && { PDRV_SFS="$ONE_SFS"; DEV1FS="$ONE_FS"; }
 fi
else #not specified anywhere
 LOOK_PUP=yes
fi
[ -z "$SAVE_BP_ID" -a "$PRAMONLY" != "yes" ] && LOOK_SAVE="yes"
if [ "$LOOK_PUP" -o "$LOOK_SAVE" ];then #something to search for
 search_func
 NUM=0
 while [ "$LOOK_PUP" -o "$LOOK_SAVE" ];do
  [ $NUM -ge $WAITDEV ] && break
  printf "${L_WAITING_FOR_DEV}\n" "$WAITDEV" "$NUM" "$WAITDEV" > /dev/console
  sleep 1
  search_func
  NUM=$(($NUM + 1))
 done
fi
[ "$P_BP_ID" ] && log_part_id "$P_BP_ID"
if [ "$PDRV_SFS" = "" ];then
 fatal_error "$DISTRO_PUPPYSFS not found." "Finding puppy main sfs file."
fi
ensure_mounted "$P_PART" "/mnt/pdrv"

#establish SAVEPART
decode_id "$SAVE_BP_ID"
[ "$ONE_PART" ] && { SAVEPART="$ONE_PART"; SAVE_BP_ID=""; }

mount -t tmpfs tmpfs /mnt/tmpfs
[ -d "/mnt/tmpfs/pup_rw" ] || mkdir /mnt/tmpfs/pup_rw

NEWUNIONRECORD=""
EXTRASFSLIST=""

do_stack_onepupdrv "$PDRV_SFS" "ro2"
STATUS=$?
if [ $STATUS -gt 0 ];then
 P_PRE_MSG="${L_PRE_MESSAGE}"
 case $STATUS in
  1) fatal_error "$(printf "${L_ERR_PDRV_INCOMPLETE}" "$PDRV_SFS")" "$P_PRE_MSG" ;;
  3) fatal_error "$(printf "${L_ERR_ONEPART_NOT_OK}" "$ONE_PART" "$ONE_REL_FN")" "$P_PRE_MSG" ;;
  4) fatal_error "$(printf "${L_ERR_ONEPART_MOUNT_SFS_FAILED}" "$ONE_PART" "$ONE_REL_FN")" "$P_PRE_MSG" ;;
  5) fatal_error "$(printf "${L_ERR_AUFS_SFS_FAILED}" "$ONE_LAYER")" "$P_PRE_MSG" ;;
 esac
fi
PUP_LAYER="$SFS_MP"

#all partition id's should be decoded by now
[ "$SAVE_BP_ID" ] && log_part_id "$SAVE_BP_ID"

[ "$SAVEPART" ] || SAVEPART="$P_PART"

#ensure that save partition is mounted
#if SAVEPART is not the same as P_PART
#moved up here to ensure config files are available
[ "$SAVEPART" ] && ensure_save_mounted

#find PUPSAVE, sortout pupmode
PUPMODE=5

PUPSAVE=""
if [ "${SAVE_MP}" != "" -a "$PRAMONLY" != "yes" ];then #have mounted save? partition
 #not sorted yet, may be pupmode=12
 if [ $PUPMODE -eq 5 ];then
  #have to find savefile/savefolder
  [ "$PUP_SAVES" ] || find_save_file "${SAVE_MP}" "$SAVEPART" "$SAVE_FS"
  echo "PUP_SAVES=${PUP_SAVES}" #debug
  if [ "$PUP_SAVES" ];then
   NUMPUP_SAVES=0
   for ONE_SAVE in $PUP_SAVES;do
    NUMPUP_SAVES=$(expr $NUMPUP_SAVES + 1)
   done
   echo "NUMPUP_SAVES=${NUMPUP_SAVES}" #debug
   if [ $NUMPUP_SAVES -eq 1 ];then
    PUPSAVE="$(echo -n $PUP_SAVES)"
   elif [ $NUMPUP_SAVES -gt 1 ];then
    CNTSAVE=1
    echo -e "\\033[1;36m" >/dev/console #36=aquablue
    echo "${L_ERR_TYPE_PUPSAVE}" > /dev/console
    echo "${L_0_NONE}" > /dev/console
    for ONETRY in $PUP_SAVES
    do
     ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d ',')"
     ONE_FILE="$(echo -n "$ONETRY" | cut -f 3 -d ',')"
     echo -e "${CNTSAVE}  ${ONE_PART}\\033[10G${ONE_FILE}" > /dev/console #10 means move to that column.
     CNTSAVE=$(expr $CNTSAVE + 1)
    done
    echo -en "\\033[0;39m" >/dev/console
    read NUMSAVE
    #--  $NUMSAVE -ne 0 = have selected a PUPSAVE ...
    if [ $NUMSAVE -ne 0 ] ; then
     echo -e "\n----" #debug
     echo "Have selected pupsave $NUMSAVE" #debug
     PUPSAVE="$(echo -n $PUP_SAVES | cut -f $NUMSAVE -d ' ')"
     PSPATH="${SAVE_MP}/$(echo "$PUPSAVE" | cut -f 3 -d ',')"
     echo "PSPATH=${PSPATH}" #debug
    fi
    #----------------------------------------------------
   fi
  fi
  echo "PUPSAVE=${PUPSAVE}" #debug
  if [ "$PUPSAVE" ];then
   echo "Setting PUPMODE 12" #debug
   PUPMODE=12
   ONE_PART="$(echo -n "$PUPSAVE" | cut -f 1 -d ',')"
   [ "$ONE_PART" != "$SAVEPART" ] && { SAVEPART="$ONE_PART"; ensure_save_mounted; }
  fi
 fi
fi

SAVE_LAYER=""
WORKDIR="/pup_work"
if [ "$PUPSAVE" ];then #refine pupmode
 # refine pupmode
 if [ $PUPMODE -eq 12 ];then
  SAVE_LAYER="/pup_rw"
  if [ -z "$PMEDIA" -o "$PMEDIA" = "cd" ] ; then
   [ "`lsblk -nro rm /dev/${SAVEPART}`" = "1" ] && xPM=13
  fi
  if [ "${PMEDIA:3}" = "flash" -o "$xPM" = "13" ];then
   PUPMODE=$(($PUPMODE + 1)) #PUPMODE=13
   echo "Setting PUPMODE $PUPMODE" #debug
   SAVE_LAYER="/pup_ro1"
  fi
  echo "SAVE_LAYER=$SAVE_LAYER" #debug
 fi
fi

#load savefile if required, then setup stack
case $PUPMODE in
 13)
  setup_psave
  if [ "$PUPSAVE" ] ; then
    #prepend ro1 - #SAVE_LAYER=/pup_ro1
    rm -rf ${SAVE_LAYER}/tmp #in case last boot was pupmode=12
    mount -o remount,size=75% /mnt/tmpfs
    remount_overlay "s~lowerdir=([^,]+)~lowerdir=${SAVE_LAYER}:\1~"
    if [ $? -eq 0 ];then
      [ "$SAVE_NAME" ] && NEWUNIONRECORD="$SAVE_NAME $NEWUNIONRECORD"
    else
      printf "${L_ADDING_SAVE_LAYER_FAILED}\n" "$SAVE_LAYER"
    fi
  fi
 ;;
 12) #replace rw
  setup_psave
  if [ "$PUPSAVE" ] ; then
    #SAVE_LAYER=/pup_rw
    #setup empty /tmp on tmpfs for in stack
    rm -rf ${SAVE_LAYER}/tmp
    #adjust stack
    remount_overlay -e "s~upperdir=[^,]+~upperdir=${SAVE_LAYER}~" -e "s~workdir=[^,]+~workdir=${WORKDIR}~"
    if [ $? -eq 0 ];then
      rm -rf /mnt/tmpfs/pup_rw
      [ "$SAVE_NAME" ] && NEWUNIONRECORD="$SAVE_NAME $NEWUNIONRECORD"
    else
      printf "${L_ADDING_SAVE_LAYER_FAILED}\n" "$SAVE_LAYER"
    fi
  fi
 ;;
 5)
  SAVE_MP=""
 ;;
esac

EXTRASFSPATHS=`find /mnt/pdrv${PSUBDIR} /mnt/pdrv /mnt/dev_save${PSUBDIR} /mnt/dev_save -maxdepth 1 -name '*.sfs' -size +0 -exec sh -c 'SFS={}; echo ${SFS##*/},$SFS' \; | sort -n | uniq | cut -f 2- -d ,`

# load traditional SFSs in the traditional order
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_BDRVSFS" "b" "p"
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_YDRVSFS" "y" "p"
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_ADRVSFS" "a" "p"
stack_onepupdrv "$EXTRASFSPATHS" "nlsx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs" "nls" ""
stack_onepupdrv "$EXTRASFSPATHS" "docx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs" "doc" ""
stack_onepupdrv "$EXTRASFSPATHS" "kbuild-${KERNELVER}.sfs" "k" ""
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_FDRVSFS" "f" ""
stack_onepupdrv "$EXTRASFSPATHS" "$DISTRO_ZDRVSFS" "z" ""

# under PUPMODE 12, a dynamically loaded SFS may leave behind symlinks in the save layer
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin chroot /pup_new /usr/sbin/sfs_load.overlay --cli stop
rm -f /pup_new/run/sfs_load.lock

# load all other SFSs, sorted numerically
CNT=3
for ONE_SFS in $EXTRASFSPATHS; do
 ONE_NAME="${ONE_SFS##*/}"

 # skip SFSs from other Puppy family distros
 case "$ONE_NAME" in
 *_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs) ;;
 puppy_*.sfs|*drv_*.sfs|kbuild-*.sfs|devx_*.sfs|nlsx_*.sfs|docx_*.sfs) continue ;;
 esac

 stack_onepupdrv "$EXTRASFSPATHS" "$ONE_NAME" "ro${CNT}" "" || continue
 if [ -z "$EXTRASFSLIST" ]; then
  EXTRASFSLIST="${ONE_NAME}"
 else
  EXTRASFSLIST="${EXTRASFSLIST} ${ONE_NAME}"
 fi
 CNT=$(($CNT + 1))
done

mkdir -p /pup_new/etc/rc.d
( # > /pup_new/etc/rc.d/PUPSTATE
echo "PUPMODE=$PUPMODE"
echo "PDEV1='$P_PART'"
echo "DEV1FS='$DEV1FS'"
echo "PUPSFS='$P_PART,$DEV1FS,${PDRV_SFS#/mnt/pdrv}'"
echo "PUPSAVE='$PUPSAVE'"
echo "PMEDIA='$PMEDIA'"
echo '#these directories are overlay layers in /initrd...'
echo "RW_LAYER='/pup_rw'"
echo "SAVE_LAYER='$SAVE_LAYER'"
echo "PUP_LAYER='$PUP_LAYER'"
echo "#The partition that has the ${DISTRO_FILE_PREFIX}save file is mounted here..."
echo "PUP_HOME='${SAVE_MP}'"
echo '#(in /initrd) ...note, /mnt/home is a link to it.'
echo '#Partition no. override on boot drive to which session is (or will be) saved...'
echo "PSAVEPART='$SAVEPART'"
echo "PSUBDIR='$PSUBDIR'"
) > /pup_new/etc/rc.d/PUPSTATE

if [ "$PUPSAVE" ];then
 xBOOTCONFIG="$(grep -v -e '^PREVUNIONRECORD' -e '^EXTRASFSLIST' /pup_new/etc/rc.d/BOOTCONFIG | sed -e 's/^LASTUNIONRECORD/PREVUNIONRECORD/')"
 echo "$xBOOTCONFIG" > /pup_new/etc/rc.d/BOOTCONFIG
else
 echo "PREVUNIONRECORD=''" >> /pup_new/etc/rc.d/BOOTCONFIG
fi
echo "EXTRASFSLIST='${EXTRASFSLIST}'" >> /pup_new/etc/rc.d/BOOTCONFIG
echo "LASTUNIONRECORD='$(echo -n $NEWUNIONRECORD)'" >> /pup_new/etc/rc.d/BOOTCONFIG

echo -n "${L_SWITCH_ROOT}" > /dev/console

echo "Moving mountpoints to /pup_new/initrd for after switch..." #debug
rm -r -f "/pup_new/initrd${SAVE_LAYER}"
for ONEMNT in $(mount | cut -f 3 -d ' ' | grep -v 'pup_new' | grep '^/pup_' | tr '\n' ' ');do
 mkdir -p /pup_new/initrd${ONEMNT}
 echo "mount -o move $ONEMNT /pup_new/initrd${ONEMNT}" #debug
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done
for ONEMNT in $(mount | cut -f 3 -d ' ' | grep '^/mnt/' | tr '\n' ' ');do
 mkdir -p /pup_new/initrd${ONEMNT}
 echo "mount -o move $ONEMNT /pup_new/initrd${ONEMNT}" #debug
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done

echo "SAVE_FN=$SAVE_FN"         #debug
echo "SAVE_LAYER=${SAVE_LAYER}" #debug

# --- create/fix symlinks to /pup_new/initrd/* for after switch

# remove symbolic links for after switch, that might be leftover
[ -L /pup_new/initrd/pup_rw ] && rm -rf /pup_new/initrd/pup_rw
[ -L /pup_new/initrd/pup_ro1 ] && rm -rf /pup_new/initrd/pup_ro1
[ -L /pup_new/tmp ] && rm -fv /pup_new/tmp

# SAVE_LAYER: /pup_rw or /pup_ro1
# savefolder: create symlink to the save layer mountpoint in /pup_new/initrd
# (for savefiles and savepartitions the SAVE_LAYER is not a symlink)
if [ "$PUPSAVE" ];then
 if [ "$SAVE_LAYER" -a -L "$SAVE_LAYER" ];then
  ln -sv "/initrd`readlink ${SAVE_LAYER}`" "/pup_new/initrd${SAVE_LAYER}" #for after switch
 fi
fi

# symlinks to /pup_new/initrd/tmpfs subdirs
# * /pup_rw:  pupmodes 5,13
# * /pup_ro1: in PUPMODE 13 pup_ro1 is part of the tmpfs but an overlay read-only branch
#             where the previous session is stored to build the final filesystem
# * (rm -rf ... is an extra measure to ensure deletion
#     since an actual directory might be there and therefore was not deleted.)
if ! grep -q '/pup_new/initrd/pup_rw' /proc/mounts ; then
  if [ -d /pup_new/initrd/mnt/tmpfs/pup_rw ] ; then
    rm -rf /pup_new/initrd/pup_rw
    ln -sv /initrd/mnt/tmpfs/pup_rw /pup_new/initrd/pup_rw #for after switch
  fi
fi
if [ -d /pup_new/initrd/mnt/tmpfs/pup_ro1 ] ; then
  rm -rf /pup_new/initrd/pup_ro1
  ln -sv /initrd/mnt/tmpfs/pup_ro1 /pup_new/initrd/pup_ro1 #for after switch
fi
mkdir -p /pup_new/initrd/mnt/tmpfs/tmp
if [ -d /pup_new/initrd/mnt/tmpfs/tmp ];then #extra paranoid precaution
 chmod 1777 /pup_new/initrd/mnt/tmpfs/tmp
 mount --bind /pup_new/initrd/mnt/tmpfs/tmp /pup_new/tmp #for after switch
fi

#---

#PNOX is a boot param. /etc/profile prevents X from starting if this file exists...
[ "$PNOX" = "yes" ] && touch /pup_new/initrd/mnt/tmpfs/tmp/bootcnt.txt

cp -a /DISTRO_SPECS /pup_new/initrd/
[ ! -f /pup_new/etc/DISTRO_SPECS ] && cp -a /DISTRO_SPECS /pup_new/etc/
dmesg > /tmp/dmesg.txt

[ -d "/pup_new/initrd/tmp" ] && rm -rf /pup_new/initrd/tmp
mkdir -p /pup_new/initrd/tmp
cp -af /tmp/* /pup_new/initrd/tmp/ #keep any log files.

if [ "$RDSH" = "yes" ];then
 echo > /dev/console
 echo "${L_DROPPED_TO_INITRD_SHELL}" > /dev/console
 exec /bin/sh >/dev/console 2>&1
fi

sync
umount /sys
umount /dev
umount /proc

#now using cpio archive for initramfs 'initial ramdisk'...
exec switch_root /pup_new /usr/local/sbin/init

###END###
