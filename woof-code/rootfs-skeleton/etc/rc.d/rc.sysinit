#!/bin/ash
#(c) copyright Barry Kauler 2008, puppylinux.com
#2008 Lesser GPL licence v2 (http://www.fsf.org/licensing/licenses/lgpl.html)
# see also initNEW -> /sbin/init, init (initramfs), rc.shutdown.
#
# How rc.sysinit is triggered:
# - /sbin/init executes busybox init or minit
# - busybox init is controlled by /etc/inittab
#   /etc/inittab: rc.sysinit is specified as ::sysinit:
# - also read /etc/inittab.README
#
# eudev is enforced - min 204+ recommended
#
#w004 LANG=C, faster. /bin/ash, even faster.
#w481 fix crappy depmod, 'out of memory' in first boot 64MB RAM (no swap).
#v424 fix secondary uevent replay. now finds ssb devices.
#100131 bugfix detect multiple cd/dvd drives.
#100703 load fbcon module: needed by some xorg drivers when exit to console (ex: nouveau).
#100814 record cumulative tx/rx, see also network_tray and rc.shutdown.
#101119 /sbin/pup_event_backend_modprobe has been rewritten, repercussions here.
#101210 new path /tmp/pup_event_backend for files logged by /sbin/pup_event_backend_*.
#110405 fix 'free' applet output format different in later versions of busybox.
#110426 move done/failed/backgrounded 2 places to right (also in init script).
#110502 fix creation of owner:group for device nodes. 110503 fix permission fsckme.flg.
#110511 2nd uevent replay: now using udevadm for usb, ssb and pcmcia.
#110513 rcrsn51: udevadm usb replay fix, properly detect scanners etc.
#110712 fixes for kernel with usb core (including usb-storage) drivers builtin.
#110814 kernel with inbuilt usb drivers, usbfs was not mounting on /proc/bus/usb.
#120217 improvement for full hd install, non-english.
#120301 need to load console font earlier.
#120301 a problem if initrd has kernel default font, switching here changes all o/p from initrd to partial garbage.
#120313 fix 120301 font garbage. 120331 clear requires redirection to /dev/console.
#120423 pemasu: /dev/mouse was missing in full install.
#120503 if kernel mounts a f.s. on /dev, removes my skeleton /dev
#120709 BOOT_UDEVDCHILDREN from /etc/rc.d/BOOTCONSTRAINED
#130311 use modinfo to test if fbcon builtin.
#130504 moved up, i think fbcon needs to be loaded before intel, nouveau modules load.
#160609 rerwin: Add wait for USB3 driver.

export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games

#================================================================
#              functions used by the script
#================================================================

status_func() {
 if [ $1 -eq 0 ];then
  echo -n -e "\\033[74G\\033[1;32m" >/dev/console #green [done] msg. 110426: change 72 to 74.
  echo -n "done" >/dev/console #done
  echo -e "\\033[0;39m" >/dev/console
 else
  echo -n -e "\\033[72G\\033[1;31m" >/dev/console #red [failed]. 110426: change 70 to 72.
  echo -n "failed" >/dev/console #failed
  echo -e "\\033[0;39m" >/dev/console
  STATUS=0
 fi
 return $1 #return with same status as entry param.
}

create_zram_swap() {
  modprobe zram >/dev/null 2>&1
  RAM=`awk '/MemTotal/{print $2}' /proc/meminfo`
  echo ${RAM}000 > /sys/block/zram0/disksize || return 1
  mkswap /dev/zram0 || return 1
  swapon /dev/zram0
}

loadswap_func() { #w481 made into a function.
 echo "LOAD SWAP"
 #load a swap partition...
 while read _ ONESWAP SWAPSIZEBYTES
 do
  EXTRAALLOCK=$(($EXTRAALLOCK + $SWAPSIZEBYTES))
  echo -n "Loading swap partition ${ONESWAP}..." >/dev/console #loading swap partition
  chmod 0660 $ONESWAP
  swapon $ONESWAP
  status_func $?
  [ $? -eq 0 ] && SWAPON="yes"
 done < <(lsblk -bnro fstype,name,size | grep ^swap)
 [ "$SWAPON" = "yes" ] && return
 #if no go, try for a swap file...
 if [ -f /initrd${PUP_HOME}/pupswap.swp ] ; then
   SWAPFILE="/initrd${PUP_HOME}/pupswap.swp"
 elif [ -f /pupswap.swp ] ; then
   SWAPFILE="/pupswap.swp"
 fi
 if [ "${SWAPFILE}" ] ; then
  SWAPSIZEBYTES=`stat -c %s ${SWAPFILE}` #bytes
  echo -n "Loading swap file ${SWAPFILE}..." >/dev/console
  chmod 0660 $SWAPFILE
  swapon ${SWAPFILE} ; ret=$? ; status_func $ret
  if [ $ret -eq 0 ] ; then
    [ "$SWAPSIZEBYTES" ] && EXTRAALLOCK=$(($EXTRAALLOCK + $SWAPSIZEBYTES))
    SWAPON="yes"
    return
  fi
 fi
 # if we failed to find a swap partition or file, try zram
 echo -n "Loading zram swap..." >/dev/console
 create_zram_swap
 ret=$?
 status_func $ret
 if [ $ret -eq 0 ] ; then
   SWAPON="yes"
 fi
}

#================================================================
#                         MAIN
#================================================================
. /etc/rc.d/PUPSTATE

. /etc/DISTRO_SPECS
[ $loglevel ] && LOGLEVEL=$loglevel #boot param.

#if have just done a switch_root, output a 'done' message...
status_func 0

export LANG=C

STATUS=0

##############MAKE FILESYSTEM USABLE################

echo -n "Making the filesystem usable..." >/dev/console

mount -t tmpfs -onosuid,noexec,size=10%,mode=755 tmpfs /run
mount -t tmpfs -onodev,noexec,nosuid,size=20%,mode=1777 /run/lock
mount -t proc -onodev,noexec,nosuid proc /proc
mount -t sysfs -onodev,noexec,nosuid sysfs /sys
mount -t pstore pstore /sys/fs/pstore
[ -d /sys/firmware/efi/efivars ] && mount -t efivarfs none /sys/firmware/efi/efivars

mount -n -o nosuid,size=10M,mode=0755 -t devtmpfs devtmpfs /dev
busybox syslogd -C128
busybox klogd

FREERAM=`free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 4 -d ' '` #w481 110405
QTRFREERAM=`expr $FREERAM \/ 4`

#===============

#redirect all output to a log file (must do after remount rw)...
if [ ! "$LOGLEVEL" ] ; then
	exec 1>/tmp/bootsysinit.log 2>&1
fi

#mount/umount scripts no longer write to /etc/mtab, as gparted failed to create a
#gparted create ext3 part. failed, fixed by making /etc/mtab a symlink.
rm -f /etc/mtab
ln -sv /proc/mounts /etc/mtab

busybox mount -t cgroup2 -o nsdelegate,memory_recursiveprot cgroup2 /sys/fs/cgroup ;STATUS=$((STATUS+$?))

# simulate what systemd does but only for /, podman needs this
busybox mount --make-shared / 2>/dev/null

# podman mounts a layered file system and it must not overlap with the one at /
if [ -e /var/lib/containers ]; then
	touch /var/lib/containers
else
	mkdir /var/lib/containers 2>/dev/null
fi
busybox mount -o bind /initrd/pup_rw/var/lib/containers /var/lib/containers ;STATUS=$((STATUS+$?))
if [ -e /home/spot/.local/share/containers ]; then
	touch /home/spot/.local/share/containers
else
	install -d -o spot -g spot /home/spot/.local /home/spot/.local/share /home/spot/.local/share/containers 2>/dev/null
fi
busybox mount -o bind /initrd/pup_rw/home/spot/.local/share/containers /home/spot/.local/share/containers ;STATUS=$((STATUS+$?))

status_func $STATUS

busybox mount -a #Load fstab entries

sysctl --system

## process some specific kernel params here
SFSLOCK=2
for i in $(cat /proc/cmdline) ; do
	case $i in
		xerrs)   rm -f /var/local/xwin_disable_xerrs_log_flag ;; # see xwin / bootmanager
		noxerrs) touch /var/local/xwin_disable_xerrs_log_flag ;; # see xwin / bootmanager
		pfix=copy|pfix=copy,*|pfix=*,copy,*|pfix=*,copy|pfix=ram|pfix=ram,*|pfix=*,ram,*|pfix=*,ram) SFSLOCK=1 ;;
		pfix=nocopy|pfix=nocopy,*|pfix=*,nocopy,*|pfix=*,nocopy) SFSLOCK=0 ;;
	esac
done

#################LOAD KERNEL MODULES################
echo "LOAD KERNEL MODULES"
echo -n "Loading kernel modules..." >/dev/console

[ -w /sys/kernel/uevent_helper ] && echo > /sys/kernel/uevent_helper
kmod static-nodes --format=tmpfiles --output=/proc/self/fd/1 | \
while read type name mode uid gid age arg; do
	[ -e $name ] && continue
	case "$type" in
	c|b|c!|b!) mknod -m $mode $name $type $(echo $arg | sed 's/:/ /') ;;
	d|d!) mkdir $name ;;
	esac
done
mkdir /run/udev
udevd --daemon
udevadm trigger --type=subsystems --action=add
udevadm trigger --type=devices --action=add
ln -sf /bin/true /dev/MAKEDEV
udevadm settle

ln -s /proc/self/fd /dev/fd
ln -s fd/0 /dev/stdin
ln -s fd/1 /dev/stdout
ln -s fd/2 /dev/stderr
mkdir --mode=755 /dev/shm
mount -t tmpfs -o nosuid,nodev,noexec,size=20%,mode=1777 tmpfs /dev/shm
mkdir --mode=755 /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=600 devpts /dev/pts

status_func 0

if [ $SFSLOCK -eq 2 ]; then
  PDEV=""
  case "$PDEV1" in
  sd*[0-9]*) PDEV="${PDEV1%%[0-9]*}" ;;
  mmcblk[0-9]*p[0-9]*) PDEV="${PDEV1%p[0-9]*}" ;;
  nvme[0-9]*n[0-9]*p[0-9]*) PDEV="${PDEV1%p[0-9]*}" ;;
  esac

  [ -n "$PDEV" ] && [ "`cat /sys/class/block/$PDEV/queue/discard_max_bytes`" = "0" ] && ! systemd-detect-virt -vq && SFSLOCK=1
fi

if [ $SFSLOCK -eq 1 ]; then
	echo -n "Copying to ram..." >/dev/console
	(
		. /etc/rc.d/BOOTCONFIG
		MEMTOTALK=$(grep -m1 ^MemTotal /proc/meminfo | awk '{print $2}')
		MEMTOTAL=$((MEMTOTALK * 1000))
		LOCKLIMIT=$((MEMTOTAL / 2))
		LOCKED=0
		FIRST=1

		# copy SFSs to RAM and prioritize frequently-accessed ones
		for SFS in $DISTRO_PUPPYSFS $DISTRO_ADRVSFS $DISTRO_YDRVSFS $DISTRO_BDRVSFS nlsx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs docx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs $DISTRO_ZDRVSFS $DISTRO_FDRVSFS kbuild-`uname -r`.sfs $EXTRASFSLIST; do
			BACKF=$(grep -l "/$SFS\$" /sys/devices/virtual/block/*/loop/backing_file | head -n 1)
			[ -z "$BACKF" ] && continue
			SFSSIZE=$(du -b $(cat $BACKF) | awk '{print $1}')
			LOCKED=$(($LOCKED + $SFSSIZE))
			[ $LOCKED -gt $LOCKLIMIT ] && break
			LOOP=${BACKF%/loop/backing_file}
			LOOP=${LOOP#/sys/devices/virtual/block/}
			[ $FIRST -eq 1 ] && sfsunlockd
			sfslock /dev/${LOOP} || break
			FIRST=0
		done
	) &
	echo -e "\\033[64G\\033[1;33m[backgrounded]\\033[0;39m" >/dev/console
fi
######################LOAD SWAP#####################
EXTRAALLOCK=0
loadswap_func
if [ "$SWAPON" = "yes" ];then
 # resize tmpfs
 # this code is meant to increase the size of the tmpfs
 EXTRAALLOCK=$(($EXTRAALLOCK / 2048)) #use half in KiB
 RAMSIZE=$(free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 2 -d ' ')
 if [ $PUPMODE -eq 12 ]; then
  FREEK=$(($RAMSIZE / 2)) #half of physical.
 else
  FREEK=$(($RAMSIZE * 3 / 4)) #3/4 of physical.
 fi
 ALLOCK=$(($FREEK + $EXTRAALLOCK))
 if [ "$(grep -m 1 '/initrd/mnt/tmpfs' /proc/mounts)" != "" ];then #mounted
  busybox mount -t tmpfs -o remount,size=${ALLOCK}k tmpfs /initrd/mnt/tmpfs
 fi
fi

# Setup /mnt/home symlink before sfs_load
rm -f /mnt/home 2>/dev/null
if [ "$PUP_HOME" ];then #see /etc/rc.d/PUPSTATE
  [ ! -d "/initrd${PUP_HOME}" ] && echo "ERROR: $PUP_HOME does not exist"
  ln -sv /initrd${PUP_HOME} /mnt/home
fi

#------ load extra sfs's if any ------
sfs_load --cli start
#-------------------------------------

#######################VERSION UPDATE##########################
echo "VERSION UPDATE"
# rc.update determines what is to be updated according to $PUMODE
echo -n "Updating..." >/dev/console
/etc/rc.d/rc.update $PUPMODE
status_func $STATUS

#rebuild out-of-tree modules if the kernel has changed
[ -e /usr/lib/dkms/dkms_autoinstaller ] && PATH="$PATH" /usr/lib/dkms/dkms_autoinstaller start 2>/dev/console

###################SETUP SERVICES################
echo "SETUP SERVICES"
echo -n "Setting up services (network" >/dev/console

#had hoped to retire this, but HardInfo, Pupscan need it... 110814 fix test...
[ -e /proc/bus/usb ] && busybox mount -t usbfs none /proc/bus/usb

hostname -F /etc/hostname

busybox hwclock -s

mkdir -p /var/run/dbus
chown messagebus /var/run/dbus
chgrp messagebus /var/run/dbus
dbus-uuidgen --ensure
dbus-daemon --system

# enable ktls, in case all internet-facing processes run as spot and cannot load tls
modprobe tls 2>/dev/null

echo -n ", printing, etc.)..." >/dev/console

#----------------------
/etc/rc.d/rc.services start & #run scripts in /etc/rc.d/init.d
#----------------------
echo -e "\\033[64G\\033[1;33m[backgrounded]\\033[0;39m" >/dev/console #column 62, yellow. 110426: 64

###################PERSONAL BOOT SCRIPT######################
echo "PERSONAL BOOT SCRIPT"
#personal boot script here...
if [ ! -f /etc/rc.d/rc.local ];then
 echo '#this file called from rc.sysinit' > /etc/rc.d/rc.local
 echo '#you can edit this file' >> /etc/rc.d/rc.local
 echo '#When firewall is installed, will append lines to this file...' >> /etc/rc.d/rc.local
else
 . /etc/rc.d/rc.local
fi

#that's it. next stop is /etc/profile...
###END###
